# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/05a_path_joining.ipynb.

# %% auto 0
__all__ = ['closest_endpoint_pair', 'join_endpoints', 'merge_closest_strokes']

# %% ../../nbs/05a_path_joining.ipynb 20
def closest_endpoint_pair(strokes):
    sorted_strokes = sorted(strokes, key=lambda s: len(s), reverse=True)

    min_dist = 1e10
    min_s_idx = None
    min_c_idx = None
    min_s_pos = None
    min_c_pos = None

    for i, s in enumerate(sorted_strokes):
        s_start = s[0]
        s_end = s[-1]
        for j, c in enumerate(sorted_strokes):
            if i == j:
                continue
            c_start = c[0]
            c_end = c[:1]

            ss_cs_dist = np.linalg.norm(s_start - c_start)
            ss_ce_dist = np.linalg.norm(s_start - c_end)
            se_cs_dist = np.linalg.norm(s_end - c_start)
            se_ce_dist = np.linalg.norm(s_end - c_end)

            # print(i, len(c), (ss_cs_dist, ss_ce_dist, se_cs_dist, se_ce_dist))

            if ss_cs_dist < min_dist:
                min_dist = ss_cs_dist
                min_s_idx = i
                min_c_idx = j
                min_s_pos = "START"
                min_c_pos = "START"
            if ss_ce_dist < min_dist:
                min_dist = ss_ce_dist
                min_s_idx = i
                min_c_idx = j
                min_s_pos = "START"
                min_c_pos = "END"
            if se_cs_dist < min_dist:
                min_dist = se_cs_dist
                min_s_idx = i
                min_c_idx = j
                min_s_pos = "END"
                min_c_pos = "START"
            if se_ce_dist < min_dist:
                min_dist = se_ce_dist
                min_s_idx = i
                min_c_idx = j
                min_s_pos = "END"
                min_c_pos = "END"
    return min_dist, min_s_idx, min_c_idx, min_s_pos, min_c_pos


def join_endpoints(strokes, min_s_idx, min_c_idx, min_s_pos, min_c_pos):
    starter = strokes[min_s_idx]
    joinee = strokes[min_c_idx]
    remaining = [x for i, x in enumerate(strokes) if i not in [min_s_idx, min_c_idx]]
    print(f"sorted_strokes ({len(strokes)}), remaining ({len(remaining)})")

    joined = None
    if min_s_pos == "START":
        if min_c_pos == "START":
            joined = np.concatenate([np.flip(joinee, axis=0), starter], axis=0)
        elif min_c_pos == "END":
            joined = np.concatenate([joinee, starter], axis=0)
        else:
            raise Exception(f"invalid min_c_pos: {min_c_pos}")
    elif min_s_pos == "END":
        if min_c_pos == "START":
            joined = np.concatenate([starter, joinee], axis=0)
        elif min_c_pos == "END":
            joined = np.concatenate([starter, np.flip(joinee, axis=0)], axis=0)
        else:
            raise Exception(f"invalid min_c_pos: {min_c_pos}")
    else:
        raise Exception(f"invalid min_s_pos: {min_s_pos}")

    return [joined] + remaining


def merge_closest_strokes(strokes, dist_threshold=10.0):
    sorted_strokes = sorted(strokes, key=lambda s: len(s), reverse=True)

    min_dist, min_s_idx, min_c_idx, min_s_pos, min_c_pos = closest_endpoint_pair(
        sorted_strokes
    )

    print(f"Minimum distance: {min_dist}")
    print(f"From {min_s_idx}_{min_s_pos} ({len(strokes[min_s_idx])} points)")
    print(f"To {min_c_idx}_{min_c_pos} ({len(strokes[min_s_idx])} points)")

    if min_dist >= dist_threshold:
        print("not merging")
        return min_dist, strokes

    return min_dist, join_endpoints(
        sorted_strokes, min_s_idx, min_c_idx, min_s_pos, min_c_pos
    )
